---
title: webpack
date: 2019-04-09 17:00:36
tags: utils
gitment: webpack
description: webpack的一些概念及一个简单的项目实践步骤
---

### 核心概念 ###
webpack的四个核心概念：entry、output、loader、plugins

### mode ###
mode 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化
```jsx
mode: 'production'
```
也可以从cli参数中传递

```jsx
webpack --mode=development/production
/* 环境不同，启用的插件不同 */
```

### entry ###
entry 指示webpack应该使用哪个模块，来作为其构建内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点（直接和间接）依赖的。
可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。
```jsx
  entry: {
    path.join(__dirname, '../src/index.js')
  }
  /* 此处用了node的path模块，join方法用于连接多个目录，自动区分windows和linux的连接符；__dirname是node的一个全局变量，获得当前文件所在目录的完整目录名 */
```

### output ###
output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。

output 的最低要求是，将它的值设置为一个对象：
1. filename 设置输出文件名；
2. path 设置目标输出目录的绝对路径。
```jsx
output: {
  filename: 'bundle.js',
  path: path.join(__dirname, '../dist')
}
```

### loader ###
loader 用于对模块的源代码进行转换。用于转换某些类型的模块，让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。
本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。<br>
在配置loader时：
1. test 用于标识出应该被对应的 loader 进行转换的某个或某些文件;
2. use 属性，表示进行转换时，应该使用哪个 loader。

```jsx
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      /*  “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 '.vue' 的路径」时，在你对它打包之前，先使用 vue-loader 转换一下。” */
      {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
            loader: 'css-loader',
            options: {
              modules: true
            }
          }
        ]
      }
    ]
  }
````
除了通过配置指定loader，还可以通过内联和cli指定（不推荐）  
除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段（不明白？）
loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。 用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多（O__O "…）


### plugins ###
plugins 用于执行范围更广的任务，从打包优化和压缩，一直到重新定义环境中的变量。<br>
想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。<br>
也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。

```jsx
const VueLoaderPlugin = require('vue-loader/lib/plugin')

plugins: [
  new VueLoaderPlugin()
]
```

### 配置 ###
webpack 的配置文件，是导出一个对象的 JavaScript 文件。此对象，由 webpack 根据对象定义的属性进行解析。  
可以用数组，导出多个配置对象。

### 构建目标 ###
```jsx
target: 'node'
// 默认值为 web
// 使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。
```


### 项目实践 ###
从零开始，搭建一个最简单的vue项目。虽然现在有各种脚手架为我们定制了完美的方案，但是总有一种摸不到深层的不安全感，亲自深入了解一下，可以对自己所做的事情有更多的掌控，这种感觉才是美好滴。

步骤：

1. 创建项目文件夹
```jsx
mkdir test-pack && cd test-pack
```

2. 初始化，生成package.json
```jsx
npm init
```

3. 安装依赖项
```jsx
npm install webpack webpack-cli webpack-dev-server --save-dev
npm install vue --save
npm install vue-loader vue-template-compiler --save-dev
npm install style-loader css-loader --save-dev
npm install html-webpack-plugin --save-dev
```
安装完成后，各依赖项如下：
```jsx
"devDependencies": {
  "css-loader": "^2.1.1",
  "html-webpack-plugin": "^3.2.0",
  "style-loader": "^0.23.1",
  "vue-loader": "^15.7.0",
  "vue-template-compiler": "^2.6.10",
  "webpack": "^4.29.6",
  "webpack-cli": "^3.3.0",
  "webpack-dev-server": "^3.3.0"
},
"dependencies": {
  "vue": "^2.6.10"
}
```

4. 组织文件结构
```jsx
"test-pack": {
  "node_modules"
  "dist"
  "config": {
    "webpack.build.js"
    "webpack.dev.js"
  }
  "src": {
    "components": {
      "app.vue"
    }
    "index.js"
  }
  "package.json"
}
```

5. app.vue
```html
<template>
  <div class="test">{{text}}</div>
</template>
<script>
export default {
  data() {
    return {
      text: '测试'
    }
  }
}
</script>
<style>
.test {
  color: red;
}
</style>
```

6. index.js
```jsx
import Vue from 'vue'
import App from './components/app.vue'

const root = document.createElement('div')
document.body.appendChild(root)

new Vue({
  render:(h) => h(App)
}).$mount(root)
```

7. 在webpack.build.js中书写打包配置
```jsx
const path = require('path')
const VueLoaderPlugin = require('vue-loader/lib/plugin')

module.exports = {
  mode: 'production',
  entry: path.join(__dirname, '../src/index.js'),
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, '../dist')
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ]
}
```

8. 在package.json中添加打包的脚本命令
```jsx
"scripts": {
  "build": "webpack --config config/webpack.build.js"
}
```
此时，运行 npm run build，可以看到文件被打包为bundle.js放在dist目录下

9. 在webpack.dev.js中书写配置，让代码在本地跑起来
```jsx
const path = require('path')
const VueLoaderPlugin = require('vue-loader/lib/plugin')
const webpack = require('webpack')
const HTMLPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'development',
  entry: path.join(__dirname, '../src/index.js'),
  output: {
    filename: 'bundle.js',
    path: path.join(__dirname, '../dist')
  },
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    new HTMLPlugin(),
    new VueLoaderPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorsPlugin()
  ],
  devServer: {
    port: 8000,
    host: '0.0.0.0',
    hot: true,
    overlay: {
      error: true
    }
  }
}
```

10. 在package.json中添加运行本地服务的脚本命令
```jsx
"scripts": {
  "dev": "webpack-dev-server --config config/webpack.dev.js",
  "build": "webpack --config config/webpack.build.js"
}
```
此时，运行npm run dev，可在本地跑起来，并支持热更新

至此，一个最简单的从零搭建项目的流程就走完了，后续可以添加更多东西以使项目变得更加完美。