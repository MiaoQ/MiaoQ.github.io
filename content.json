[{"title":"echarts的简单使用","date":"2019-05-05T11:32:04.000Z","path":"2019/05/05/tips-2019-05-05-echarts的简单使用/","text":"安装echarts 1npm install echarts --save 在react组件文件中引入相关依赖 123import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/pie'import 'echarts/lib/component/graphic' 配置饼图数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const option = &#123; \"graphic\": [&#123; // 设置圆环内的文本内容 \"type\": \"text\", \"left\": \"center\", \"top\": \"40%\", // 文字位置 \"style\": &#123; \"text\": \"总人数\", \"fill\": \"#666\", \"textAlign\": \"center\", \"fontSize\": 16 &#125; &#125;, &#123; \"type\": \"text\", \"left\": \"center\", \"top\": \"50%\", \"style\": &#123; \"text\": \"100个\", \"fill\": \"#1b1d1e\", \"fontSize\": 24 &#125; &#125;], \"series\": [&#123; // 环，这里可以是对象，也可以是数组，只有一项时可用对象；多项时，多个环 \"type\": \"pie\", \"radius\": [\"50%\", \"54%\"], // 环的粗细 \"itemStyle\": &#123; \"shadowBlur\": 10, \"shadowOffsetX\": 0, \"shadowOffsetY\": 4 &#125;, \"rich\": &#123; // 富文本样式 \"name\": &#123; \"color\": \"#666c70\" &#125;, \"value\": &#123; \"color\": \"#1b1d1e\" &#125; &#125;, \"label\": &#123; // 统一设置环的标签样式 \"textStyle\": &#123; \"fontSize\": 14, \"lineHeight\": 22 &#125; &#125;, \"labelLine\": &#123; // 统一设置环的线样式 \"lineStyle\": &#123; \"color\": \"#e0e6ec\" &#125;, \"length2\": 40 &#125;, \"data\": [&#123; // 具体的数据项，可针对不同的数据项设置不同的样式 \"name\": \"男生\", \"value\": 60, \"label\": &#123; // 对数据项设置标签样式 \"show\": true, \"rich\": &#123; // 数据项的富文本，在下面的formatter里使用了 \"name\": &#123; \"color\": \"#666c70\", \"fontSize\": 14 &#125;, \"value\": &#123; \"color\": \"#1b1d1e\", \"fontSize\": 14 &#125; &#125;, // &#123;a&#125;指series.name &#123;b&#125;指series.data的name // &#123;c&#125;指series.data的value &#123;d&#125;%指这一部分占总数的百分比 \"formatter\": \"&#123;name|&#123;b&#125;&#125;\\n&#123;value|&#123;d&#125;% &#123;c&#125;&#125;\" &#125;, \"labelLine\": &#123;// 对数据项设置线的样式 \"show\": true &#125;, \"itemStyle\": &#123;// 对数据项设置颜色、阴影等 \"color\": \"#8d81ff\", \"shadowColor\": \"#8d81ff\" &#125; &#125;, &#123; \"name\": \"女生\", \"value\": 40, \"label\": &#123; \"show\": true, \"rich\": &#123; \"name\": &#123; \"color\": \"#666c70\", \"fontSize\": 14 &#125;, \"value\": &#123; \"color\": \"#1b1d1e\", \"fontSize\": 14 &#125; &#125;, \"formatter\": \"&#123;name|&#123;b&#125;&#125;\\n&#123;value|&#123;d&#125;% &#123;c&#125;&#125;\" &#125;, \"labelLine\": &#123; \"show\": true &#125;, \"itemStyle\": &#123; \"color\": \"#ff7045\", \"shadowColor\": \"#ff7045\" &#125; &#125;] &#125;]&#125; 画布元素 1&lt;div id=\"pie\" style=&#123;&#123; width: '100%', height: 300 &#125;&#125;&gt;&lt;/div&gt; 初始化图表 123const pieDom = document.getElementById('pie')const pie = echarts.init(option)pie.setOption(option)","comments":true,"tags":[{"name":"tips","slug":"tips","permalink":"https://miaoq.github.io/tags/tips/"}]},{"title":"小技巧总结","date":"2019-05-05T09:06:00.000Z","path":"2019/05/05/tips-2019-05-05-小技巧总结/","text":"居中对齐关于水平居中对齐、垂直居中对齐，什么margin: auto、line-height…都被总结烂了，这里只列举一种最通用的：在不定宽高的情况下，水平垂直居中一个元素（用这种方法父元素和子元素都需要设置样式）：123456789.father &#123; position: relative; .child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&#125; 搞定！前几年css3的普及程度不高，所以大家嫌写前缀麻烦都不喜欢用这种方式，现在都什么年代了，所以，大胆用起来！说一说我喜欢这种方式的理由吧：其一，“不定宽高”，自由洒脱，放荡不羁，这一点还不够吸引人么。其二，这是一段可以靠理解来记忆的css代码，首先，让子元素脱离文档流，但是定位还是要相对于父元素，因而有了.father {position: relative;}和.child {position: absolute;}；然后，让子元素大体上居中.child {top: 50%; left: 50%;}；最后，我们来考虑子元素的宽高问题，让多移动的部分“缩”回去，实现子元素真正“居中”.child {transform: translate(-50%, -50%);}。 利用vw实现宽度铺满，固定宽高比的背景图在一些场景中（如轮播图），我们时常需要图片宽度铺满屏幕，而宽高比为固定值，如4:3，2:1等。此时，vw就派上用场了，vw(viewport width)是视口宽度单位，100vw相当于width: 100%。要实现宽度铺满屏幕，而高度随宽度自适应并保持一定的比例，可采用下面的方式：123&lt;a class=\"item\" href=\"www.baidu.com\"&gt; &lt;div class=\"img\" style=\"background-image: url(&#123;&#123;imgUrl&#125;&#125;)\"&gt;&lt;/div&gt;&lt;/a&gt; 1234567891011.item &#123; display: block; overflow: hidden; width: 100vw; .img&#123; width: 100%; height: 75vw; background-size: cover; background-position: center; &#125;&#125; 利用padding实现固定宽高比的背景图padding在使用百分比设置的时候是相对于宽度来计算的，利用这一点，可以实现固定宽高比的背景图。1234567.img&#123; width: 100%; height: 0; padding-top: 75%; background-size: cover; background-position: center;&#125; 利用flex实现每行n个盒子的布局以下代码实现了每行三个盒子的布局，当盒子高度不一致时，所有盒子的高度都以最高的那个为准12345678910111213.container &#123; display: flex; flex-wrap: wrap; justify-content: space-between; position: relative; &amp;::after &#123; // 添加伪元素解决最后一行为两个盒子时，两端对齐的问题 content: \"\"; width: 31.5%; &#125; .item &#123; width: 31.5%; &#125;&#125;","comments":true,"tags":[{"name":"tips","slug":"tips","permalink":"https://miaoq.github.io/tags/tips/"}]},{"title":"导出json数据到excel","date":"2019-05-05T08:07:21.000Z","path":"2019/05/05/tips-2019-05-05-导出json数据到excel/","text":"安装依赖项123npm install file-saver --savenpm install xlsx --savenpm install script-loader --save-dev 下载文件下载所需文件Blob.js和Export2Excel.js 代码组织部分 在src目录下新建excel文件夹，将上面下载的Blob.js和Export2Excel.js放入excel文件夹中 在存放model的文件中（我这里是store目录下的common.js）添加如下函数，实现将json数据导出为excel文件： 12345678export2Excel(context, param) &#123; // 导出excel require.ensure([], () =&gt; &#123; const &#123; export_json_to_excel &#125; = require('../excel/Export2Excel') const &#123; fileName, header, headerKey, dataSource &#125; = param const data = dataSource.map(v =&gt; headerKey.map(j =&gt; v[j])) export_json_to_excel(header, data, fileName) &#125;)&#125; 当向后台发起“导出”的ajax请求并得到响应后，返回的json数据大致如下： 1234567891011res.data = [&#123; \"id\": \"01\", \"name\": \"张三\", \"age\": 16, \"location\": \"上海\"&#125;, &#123; \"id\": \"02\", \"name\": \"李四\", \"age\": 19, \"location\": \"杭州\"&#125;] 在成功得到返回数据后，调用export2Excel，将数据导出：123456export2Excel(&#123; fileName: '人员信息记录表', header: ['编号', '姓名', '年龄', '地址'], headerKey: ['id', 'name', 'age', 'location'], dataSource: res.data&#125;)","comments":true,"tags":[{"name":"tips","slug":"tips","permalink":"https://miaoq.github.io/tags/tips/"}]},{"title":"webpack","date":"2019-04-09T09:00:36.000Z","path":"2019/04/09/utils-2019-04-09-webpack/","text":"核心概念webpack的四个核心概念：entry、output、loader、plugins modemode 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化1mode: 'production' 也可以从cli参数中传递 12webpack --mode=development/production/* 环境不同，启用的插件不同 */ entryentry 指示webpack应该使用哪个模块，来作为其构建内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点（直接和间接）依赖的。entry 的配置值可以是string | object | array可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。1234entry: &#123; path.join(__dirname, '../src/index.js')&#125;/* 此处用了node的path模块，join方法用于连接多个目录，自动区分windows和linux的连接符；__dirname是node的一个全局变量，获得当前文件所在目录的完整目录名 */ outputoutput 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。 output 的最低要求是，将它的值设置为一个对象： filename 设置输出文件名； path 设置目标输出目录的绝对路径。1234output: &#123; filename: 'bundle.js', path: path.join(__dirname, '../dist')&#125; loaderloader 用于对模块的源代码进行转换。用于转换某些类型的模块，让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。在配置loader时： test 用于标识出应该被对应的 loader 进行转换的某个或某些文件; use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112131415161718192021222324 module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader' &#125;, /* “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 '.vue' 的路径」时，在你对它打包之前，先使用 vue-loader 转换一下。” */ &#123; test: /\\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;` 除了通过配置指定loader，还可以通过内联和cli指定（不推荐）除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段（不明白？）loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。 用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多（O__O “…） pluginsplugins 用于执行范围更广的任务，从打包优化和压缩，一直到重新定义环境中的变量。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 12345const VueLoaderPlugin = require('vue-loader/lib/plugin')plugins: [ new VueLoaderPlugin()] 配置webpack 的配置文件，是导出一个对象的 JavaScript 文件。此对象，由 webpack 根据对象定义的属性进行解析。可以用数组，导出多个配置对象。 构建目标123target: 'node'// 默认值为 web// 使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。 项目实践从零开始，搭建一个最简单的vue项目。虽然现在有各种脚手架为我们定制了完美的方案，但是总有一种摸不到深层的不安全感，亲自深入了解一下，可以对自己所做的事情有更多的掌控，这种感觉才是美好滴。 步骤： 创建项目文件夹 1mkdir test-pack &amp;&amp; cd test-pack 初始化，生成package.json 1npm init 安装依赖项 12345npm install webpack webpack-cli webpack-dev-server --save-devnpm install clean-webpack-plugin html-webpack-plugin webpack-merge --save-devnpm install vue --savenpm install vue-loader vue-template-compiler --save-devnpm install style-loader css-loader --save-dev 安装完成后，各依赖项如下：123456789101112131415\"devDependencies\": &#123; \"clean-webpack-plugin\": \"^2.0.1\", // build之前先清空dist目录 \"css-loader\": \"^2.1.1\", \"html-webpack-plugin\": \"^3.2.0\", // 自动管理输出的index.html文件 \"style-loader\": \"^0.23.1\", \"vue-loader\": \"^15.7.0\", \"vue-template-compiler\": \"^2.6.10\", \"webpack\": \"^4.29.6\", \"webpack-cli\": \"^3.3.0\", \"webpack-dev-server\": \"^3.3.0\", \"webpack-merge\": \"^4.2.1\" // 处理通用配置&#125;,\"dependencies\": &#123; \"vue\": \"^2.6.10\"&#125; 组织文件结构 12345678910111213141516\"test-pack\": &#123; \"node_modules\" \"dist\" \"config\": &#123; \"webpack.base.js\" \"webpack.dev.js\" \"webpack.prod.js\" &#125; \"src\": &#123; \"components\": &#123; \"app.vue\" &#125; \"index.js\" &#125; \"package.json\"&#125; app.vue 1234567891011121314151617&lt;template&gt; &lt;div class=\"test\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; text: '测试' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.test &#123; color: red;&#125;&lt;/style&gt; index.js 123456789import Vue from 'vue'import App from './components/app.vue'const root = document.createElement('div')document.body.appendChild(root)new Vue(&#123; render:(h) =&gt; h(App)&#125;).$mount(root) 在webpack.base.js中书写通用配置 123456789101112131415161718192021222324252627282930const path = require('path')const VueLoaderPlugin = require('vue-loader/lib/plugin')const HTMLPlugin = require('html-webpack-plugin')module.exports = &#123; entry: path.join(__dirname, '../src/index.js'), output: &#123; filename: '[name].[chunkhash].js', // hash值确保浏览器拿取最新文件 path: path.join(__dirname, '../dist') &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader' &#125;, &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), new HTMLPlugin(&#123;title: '测试'&#125;) ]&#125; 在webpack.dev.js中书写开发环境的配置，让代码在本地跑起来 12345678910111213141516171819const merge = require('webpack-merge')const base = require('./webpack.base')const webpack = require('webpack')module.exports = merge(base, &#123; mode: 'development', plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() ], devServer: &#123; port: 8000, host: '0.0.0.0', hot: true, overlay: &#123; error: true &#125; &#125;&#125;) 在package.json中添加运行本地服务的脚本命令 123\"scripts\": &#123; \"dev\": \"webpack-dev-server --config config/webpack.dev.js\"&#125; 此时，运行npm run dev，可在本地跑起来，并支持热更新 在webpack.build.js中书写生产环境的打包配置 12345678910const merge = require('webpack-merge')const base = require('./webpack.base')const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = merge(base, &#123; mode: 'production', plugins: [ new CleanWebpackPlugin() ]&#125;) 在package.json中添加打包的脚本命令 1234\"scripts\": &#123; \"dev\": \"webpack-dev-server --config config/webpack.dev.js\", \"build\": \"webpack --config config/webpack.prod.js\"&#125; 此时，运行 npm run build，可以看到文件被打包为bundle.js放在dist目录下，同时自动生成index.html，点击运行index.html可以看到网页跟本地运行一样的效果 由于添加了html-webpack-plugin插件，在dist目录下自动生成了index.html 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\" src=\"main.40cda2cd05192f9fc326.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开index.html可以查看效果 至此，一个最简单的从零搭建项目的流程就走完了，后续可以添加更多东西以使项目变得更加完美。 tips在配置时，有很多详细的参数，可以到配置查询具体使用指南 通过安装依赖，可以使用不同的语言来书写配置文件，如typeScript/coffeeScript/jsx/babel等 除了导出单个配置对象，还可以导出一个函数、Promise、多个对象 entry 简单规则：每个 HTML 页面都有一个入口起点，单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点 错误处理机制 loader 总是从右到左地被调用（loader的调用很有讲究，可以抽空研究） 模块方法：ES6/CommonJS/AMD 编写一个插件 package.json里面移除”main”: “index.js”，添加”private”: true，防止意外发布代码 图片等静态资源可以统一放到一个公共的地方，不过为了方便引入，可以使用alias修改路径 Manifest可以对“模块映射到输出 bundle 的过程”进行追踪 通常为不同的环境编写不同的配置，可以用 webpack-merge 处理通用配置，不必重复代码 建议在生产环境中使用 uglifyjs-webpack-plugin 和 inline-source-map CommonsChunkPlugin 提取公共 bundle ，防止代码重复 webpack-chart 等 bundle 分析工具 离线PWA/workBox 使用环境变量NODE_ENV webpack 可以跟其它工具集成 loaders plugins 一点感悟 工作中做项目时，前辈们早已搭好环境，抑或网上早有官方出品的各种“完美”脚手架，但是只有亲自研究一番，才拥有真正属于自己一份信心与豁然； 日常工作每天都有接触，照理说随便花点时间看看资料就明白了，但是一旦开始一个新的目标，我喜欢把它吃透一点，生怕错过什么了不得的风景。事实证明，我的想法是对的。刚开始只花了几个小时就能自己搭建一个环境出来，本来满心欢喜地准备收工，但心里总不踏实，于是耐着性子把官方所有文档都看了一遍，再从网上找了视频来看。在看文档的过程中，才发现自己最先搭的环境很粗糙，后来添加了 html-webpack-plugin 来自动生成index.html文件，添加了 clean-webpack-plugin 来清理dist目录，添加了 webpack-merge 来处理重复代码……这样，项目才一步一步变成自己喜欢的样子。在看视频的时候，也是发现了些新大陆，比如，node_modules 目录下的 .bin 放的是可执行文件，直接点击里面的文件，可以实现点击应用程序图标的效果，虽然这些不是什么了不得的东西，但是，重新拾起这些被忽略的点，也是很酷的呀。","comments":true,"tags":[{"name":"utils","slug":"utils","permalink":"https://miaoq.github.io/tags/utils/"}]},{"title":"支持PWA功能","date":"2018-07-24T06:04:42.000Z","path":"2018/07/24/projects-2018-07-24-为博客添加PWA功能/","text":"PWA可以做什么？一个PWA应用首先是一个网页，可以通过Web技术编写出一个网页应用，随后添加上App Manifest和Service Worker来实现PWA的安装和离线等功能。 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 看了PWA的功能是不是激动不已，网页也可以像app一样使用了！ 如何部署？虽然PWA技术是在2016年6月才推广的项目，但是网上已经有很多介绍其原理以及如何应用的文章，这里不再赘述，仅仅记录一下如何将其简单部署到该博客上。 将项目变成一个简单的PWA应用，分为三步： 在index.html中&lt;head&gt;中添加&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;，在&lt;body&gt;中添加： 12345678910111213&lt;script&gt; if(navigator.serviceWorker != null) &#123; window.addEventListener('DOMContentLoaded', function() &#123; // 执行注册 navigator.serviceWorker.register('/service-worker.js') .then(function(registration) &#123; &#125;).catch(function(err) &#123; // Eat it! &#125;); &#125;); &#125;&lt;/script&gt; 添加manifest.json文件，以及合适像素的图片作为应用的图标 添加service-worker.js文件","comments":true,"tags":[{"name":"projects","slug":"projects","permalink":"https://miaoq.github.io/tags/projects/"}]},{"title":"Canvas","date":"2018-07-17T02:33:38.000Z","path":"2018/07/17/HTML-2018-07-17-Canvas/","text":"1. 基础知识canvas元素的大小应该直接在元素里面设置（默认值是300*150），不要用css来控制：canvas实际上有两套尺寸，一是元素本身的大小，二是元素绘图表面的大小。用元素属性设置width和height时，同时修改了两套尺寸。而用css修改时，只会改变元素本身的大小，当两者大小不一致时，浏览器会对绘图表面进行缩放，比例就不对了。 在设置canvas的宽高时，不能使用”px”后缀，虽然浏览器还是支持的，但是Canvas规范不接受。 Chrome Developer Tools以编程的方式来启动和停止性能分析（在执行某几行代码时进行分析）：console.profile() console.profileEnd() 性能分析：https://jsperf.com/ 事件处理：将鼠标坐标转换为canvas坐标 让浏览器不再干预canvas的事件处理：preventDefault() 任何放入canvas元素主体部分的东西，只有浏览器在不支持canvas元素时，才会被显示出来。所以，要让html元素“嵌入”canvas中，采用css定位实现：一、css中规定：采用绝对定位方式的元素将被绘制在采用相对定位方式的元素之上。所以，对canvas采用相对，对html采用绝对；二、两个元素都采用相对或绝对，把html放置到canvas之后三、两个元素都采用相对或绝对，添加z-index canvas并不是图像，要想让用户实现向右击鼠标保存图片的效果，使用canvas的toDataURL()方法，可抓取canvas的快照toDataURL()方法所返回的引用，指向了某个给定canvas元素的数据地址，可以将img元素的src属性设置为这个数据地址，就可以创建一幅表示canvas的图像了 2. 绘制橡皮筋技术 填充路径时使用“非零环绕规则”（剪纸效果）：从需要判断的区域出发，画一条足够长的线段（穿过该方向上的所有边），与边相交的地方计数，与顺时针相交，加一，与逆时针相交，减一。最终值是0，不填充，否则，填充。 在一个整像素的范围内绘制半个像素宽的线段是不可能的，所以版左右（上下）两个方向上的半像素都被扩展为一个像素。这样，在某两个像素的边界处绘制一条1像素宽的线段，那么该线段实际会占据2个像素的宽度。所以，取像素的.5的地方（一个整像素的中心点）开始绘制，才能绘出一个像素宽的线段。 线段的绘制：beginPath()（清除当前路径中的所有子路径，开始一段新的路径）、moveTo()（该方法会向当前路径中加入一条仅包含一个点的子路径）、lineTo()、stroke() 很多时候在需要对图形就行平移、缩放、旋转的变换时，换个角度思考：变换坐标系会更加方便（rotate() scale() translate()）。scale(-1, 1)可以绘制水平镜像更强大的变换：transform() setTransform() 图像合成（叠加，有好几种模式）：如何将一个图形绘制到另一个图形之上 剪辑区域：是在canvas中由路径定义的一块区域，浏览器会将所有的绘图操作都限制在本区域内执行，默认情况下，剪辑区域的大小与canvas一致。（利用该技术可以实现很多效果：橡皮擦、伸缩式动画…） 3. 文本像绘制图像一样，在对文本进行填充及描边操作时，除了使用纯色，还可以使用图案及渐变色 绘图环境对象的font属性也支持css3格式的字型语法，除了css特有的inherit和initial（设为这两个值，会悄无声息地失败）。设置line-height时会被忽略，canvas规定必须设置为normal 文本定位：textAlign（水平） textBaseline（垂直） 文本的度量：measureText()可以度量某个字符串的像素宽度（需要先设置好字型） 4. 图像与视频可以选择绘制某幅图的全部或部分，可以在绘制的时候缩放或保持原样，可以将图片绘制在canvas中的任何地方，也可以操作每个像素的颜色和透明度","comments":true,"tags":[{"name":"HTML","slug":"HTML","permalink":"https://miaoq.github.io/tags/HTML/"}]},{"title":"MongoDB","date":"2018-06-24T10:40:00.000Z","path":"2018/06/24/DB-2018-06-24-MongoDB/","text":"概念解析 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table.joins() 表连接，MongoDB不支持 primary key primary key 主键，MongoDB自动将_id字段设置为主键 结构数据库有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库： admin：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 文档文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 文档中的键/值对是有序 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档) 不能有重复的键 文档的键是字符串 以下划线”_”开头的键是保留的(不是严格要求的) 集合集合就是 MongoDB 文档组，类似于关系数据库管理系统中的表格，集合存在于数据库中，集合没有固定的结构 集合名不能以”system.”开头 不要在名字里出现$ 元数据ObjectId 类似唯一主键，前4个字节是时间戳，_id键的值默认是个 ObjectId 对象，ObjectId().getTimestamp()可获取文档的创建时间 基本操作以管理员身份打开控制台，输入mongo进入命令控制台: 显示： show dbs显示所有数据库的列表 db显示当前数据库对象或集合 show collections查看已有集合 show tables显示当前数据库下的所有集合 use + dbName切换到指定数据库（如果数据库不存在，则创建数据库） 删除： db.dropDatabase()删除当前数据库 db.collectionName.drop()删除整个collection 创建： db.createCollection(name, options)创建集合 db.collectionName.insert(document)插入文档 db.collectionName.save(document)不指定 _id 字段跟insert一样，指定 _id 字段，则会更新该 _id 的数据 db.collectionName.update({query}, {update}, {options})更新文档 db.collectionName.remove({query}, {options})删除文档 查找： db.collectionName.find({query}, projection)query中AND直接以逗号分隔key：{key1:value1, key2:value2}，OR则使用{$or: [{key1: value1}, {key2:value2}]}，AND和OR可组合使用 db.collectionName.find().limit(num)指定读取的条数 db.collectionName.find().skip(num)指定跳过的条数 db.collectionName.find().sort({key: 1})对指定的key排序（升序1，降序-1） 其它方法： db.collectionName.createIndex(keys, options)创建索引 db.collectionName.aggregate(options)聚合方法，计算某个字段的总和、平均值等http://www.runoob.com/mongodb/mongodb-aggregate.html 其它操作条件操作符条件|操作符–|–大于|$gt小于|$lt大于等于|$gte小于等于|$lte 12db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;)//获取\"col\"集合中 \"likes\" 大于等于 100 的数据 $type操作符是基于BSON类型来检索集合中匹配的数据类型，并返回结果。http://www.runoob.com/mongodb/mongodb-operators-type.html 管道的概念http://www.runoob.com/mongodb/mongodb-aggregate.html管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。 12345678db.articles.aggregate([ &#123; $match : &#123; score : &#123; $gt : 70, $lte : 90 &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;]);/*$match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理*/ MongoDB 复制（副本集）MongoDB复制是将数据同步在多个服务器的过程。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。复制还允许您从硬件故障和服务中断中恢复数据。 MongoDB 分片在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。 MongoDB 备份(mongodump)与恢复(mongorestore)备份数据命令mongodump恢复数据命令mongorestore MongoDB 监控在你已经安装部署并允许MongoDB服务后，你必须要了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。进入安装MongoDB目录下的bin目录使用命令：mongostat间隔固定时间获取mongodb的当前运行状态，并输出mongotop &lt;options&gt;跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据 连接数据库java：http://www.runoob.com/mongodb/mongodb-java.htmlPHP：http://www.runoob.com/mongodb/mongodb-php.htmlNode.js：http://www.runoob.com/nodejs/nodejs-mongodb.html 深入MongoDB 关系嵌入式关系：数据保存在单一的文档中，容易获取和维护，但读写性能差引用式关系：数据保存在不同的文档中，结构清晰 MongoDB 数据库引用使用 DBRefs，可以让一个文档从多个集合中引用文档。 MongoDB 覆盖索引查询尽量使用索引查询，从索引中获取数据比通过扫描文档读取数据要快得多，数据量大的时候，效果更明显。 MongoDB 查询分析explain() 操作提供了查询信息，使用索引及查询统计等,有利于我们对索引的优化hint()可强制 MongoDB 使用一个指定的索引 MongoDB 原子操作mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。 MongoDB 高级索引http://www.runoob.com/mongodb/mongodb-advanced-indexing.html索引数组索引子文档 MongoDB 索引限制http://www.runoob.com/mongodb/mongodb-indexing-limitations.html使用索引有一些限制条件 MongoDB ObjectIdObjectId() 中存储了4个字节的时间戳，所以你不需要为你的文档保存时间戳字段，可以通过 getTimestamp 函数来获取文档的创建时间。 MongoDB Map ReduceMap-Reduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。 12345678910db.collection.mapReduce( function() &#123;emit(key,value);&#125;, //map 函数 function(key,values) &#123;return reduceFunction&#125;, //reduce 函数 &#123; out: collection, query: document, sort: document, limit: number &#125;) MongoDB 全文检索http://www.runoob.com/mongodb/mongodb-text-search.html全文检索对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。 MongoDB 正则表达式MongoDB使用$regex操作符来设置匹配字符串的正则表达式。 MongoDB 管理工具: RockmongoRockMongo是PHP5写的一个MongoDB管理工具。 MongoDB GridFShttp://www.runoob.com/mongodb/mongodb-gridfs.htmlGridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。GridFS 可以更好的存储大于16M的文件。GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。 MongoDB 固定集合（Capped Collections）http://www.runoob.com/mongodb/mongodb-capped-collections.htmlMongoDB 固定集合（Capped Collections）是性能出色且有着固定大小的集合，对于大小固定，我们可以想象其就像一个环形队列，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素。 MongoDB 自动增长MongoDB 没有像 SQL 一样有自动增长的功能，可以通过编程的方式实现。","comments":true,"tags":[{"name":"DB","slug":"DB","permalink":"https://miaoq.github.io/tags/DB/"}]},{"title":"心情墙项目","date":"2018-06-20T11:32:21.000Z","path":"2018/06/20/projects-2018-06-20-心情墙项目/","text":"项目地址：https://github.com/MiaoQ/react-app-1 写在前面最近学习了时下前端较为火热的MVVM框架React，于是心痒痒的想要做个东西出来。焦急又焦急，不知道做个什么东西出来比较好，搜了搜别人都在做什么，还是没灵感（其实我特别想做一个微博那样的东东，但是觉得后台好可怕，数据库好复杂…暂时搁置）。实在想不到了，就学别人做个记事本吧，搜到一个做记事本的项目，用IndexedDB存储数据，还好，还在前端范畴，开始动手。 大框架搭了一点点，越看越不顺眼，做个记事本感觉一点也不好玩，InddexedDB也不怎么好管理，于是造型开始往微博的样子在变化，数据库也由mongoDB代替…折折腾腾十几天，终于收获战果，大大的满足。 罗里吧嗦这么多，其实就想谈谈我的两点最大的感触：一、自己喜欢的才是最好的，刚开始做的记事本排版和逻辑都不是我想要的，越做越难受，不仅没动力，还有嚼蜡的感觉；二、不要无限扩大对未知事物的畏惧，渡过开头的难关，柳暗花明又是一村。 大致过程一、使用create-react-app来构建React环境。 二、一个完整的应用大致需要三个部分：视图呈现 + 数据交互 + 数据处理 视图呈现先在脑海中设计好自己想要的界面结构，再将构图拆分成一个个组件，在写每一个组件的时候要清楚的知道数据的流动。在需要数据交互的地方，先用静态数据填充，并留好api。 数据交互数据交互就是前台与后台的数据传递，首先想到ajax，对于我个人来说，非常不喜欢使用原生的XMLHttpRequest来写，之前写了几次结构都有点乱。然后想到jQuery，但是很多人也不建议在React中使用。再继续搜，选定了fetch。 自己写项目，肯定自己要用得顺手，最不喜欢每次用个东西都跑过去复制，于是开始封装fetch，封装成了自己能记住的样子。 数据处理引用Node.js的Express模块搭建一个简单的server，处理来自前台的请求，对数据库进行操作。 Node.js提供了操作MongoDB的方法，连接数据库，再次封装成自己喜欢的方式。 小结本项目从前端页面呈现到后台服务器搭建以及数据库操作，全都使用js搞定，是前端工程师的一大福音。 在完成每一部分的时候都要有模块化的思想，server、数据库的操作、fetch方法的封装、React组件的构建…当项目从记事本的样子变成微博的样子，只需移除那些不想要的组件，是非常有魅力的一件事。 有些灵感会在项目进行中一点点迸发出来，比如功能的扩展，处理数据的方式，甚至是文件夹的摆放…不要轻易放过它们，一切都会向着更美好的方向前进。","comments":true,"tags":[{"name":"projects","slug":"projects","permalink":"https://miaoq.github.io/tags/projects/"}]},{"title":"NodeJs","date":"2018-06-14T02:04:02.000Z","path":"2018/06/14/JS-2018-06-14-NodeJs/","text":"开篇简介Node.js是javascript的一个运行环境，使用的语言自然也是javascript。安装之后，可以在控制台直接输入node进入执行环境（也就是直接输入js语句可以执行，退出按两次ctrl + c）。你也可以创建一个js文件，然后在控制台输入node filename.js执行这个文件。 Node.js REPL(交互式解释器) Node REPL 支持输入多行表达式，Node 会自动检测是否为连续的表达式（你只需回车换行即可） 可以使用下划线(_)获取上一个表达式的运算结果 REPL 命令: ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 搭建服务器Node.js可以直接搭建服务器端，这对于一个对后端语言有深深恐惧感，但又想要拥有能自己控制的server的前端媛来说简直是巨大的福音，因为，可以用js来搭建server了！并且非常简单。看一个例子就知道了：1234567var http = require('http');http.createServer(function(request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.end('Hello World!\\n');&#125;).listen(8888);console.log('Server running at http://127.0.0.1:8888/'); NPMNPM是随同NodeJS一起安装的包管理工具 查看所有npm的命令：npm help 使用npm安装模块：nmp install &lt;moduleName&gt;（本地安装）npm install &lt;modulaName&gt; -g（全局安装） 查看所有全局安装的模块：npm list -g 查看某个模块的版本号：npm list &lt;moduleName&gt; 卸载模块：npm uninstall &lt;moduleName&gt; 卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：npm ls 更新模块：npm update &lt;moduleName&gt; 搜索模块：npm search &lt;moduleName&gt; 创建模块：使用 NPM 生成 package.json 文件（以后进阶再仔细研究） package.jsonpackage.json位于模块的目录下，用于定义包的属性 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 主要内容Node.js 回调函数回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数 Node.js 事件循环在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数，回调函数接收错误对象作为第一个参数 Node.js EventEmitterevents 模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发 12345678var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('some_event', function() &#123; console.log('some_event 事件触发'); &#125;); setTimeout(function() &#123; event.emit('some_event'); &#125;, 1000); EventEmitter的属性：addListener on once removeListener removeAllListeners setMaxListeners listeners 类方法：listenerCount 事件：newListener removeListener EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 Node.js Buffer(缓冲区)JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 Node.js Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。从流中读数据 将数据写入流管道流 用于从一个流中获取数据并将数据传递到另外一个流中链式流 可以对流进行压缩、解压等处理 Node.js模块系统为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript代码、JSON或者编译过的C/C++扩展。 12345678910111213//创建模块 hello.jsexports.world = function() &#123; console.log('hello world');&#125;//或者：module.exports = function() &#123; console.log('hello world');&#125;//或者：function Hello() &#123; console.log('hello world');&#125;module.exports = Hello; 123//引用模块 main.jsvar Hello = require('./hello');//./表示当前目录，省略了文件名后缀.jshello = new Hello(); Node.js 函数在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 Node.js 路由通过请求的path name来决定作什么样的response 12345//router.jsfunction route(pathname) &#123; console.log('About to route a request for ' + pathname);&#125;exports.route = route; 123456789101112131415161718192021//server.jsvar http = require('http');var url = require('url');function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log('Request for ' + pathname + ' received.'); route(pathname); response.write(200, &#123;'Content-Type': 'text/plain'&#125;); response.write('hello world'); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log('Server has started.');&#125;exports.start = start; 12345//index.jsvar server = require('./server');var router = require('./router');server.start(router.route); Node.js 全局对象Node.js 中的全局对象是 global，可以直接访问到 global 的属性，而不需要在应用中包含它 __filename 表示当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径 __dirname 表示当前执行脚本所在的目录 setTimeout(cb, ms) clearTimeout(t) setInterval(cb, ms) console process用于描述当前Node.js 进程状态的对象 console方法 描述 console.log([data][, …]) 向标准输出流打印字符并以换行符结束（可以加%d那种） console.info([data][, …]) 信息性消息（蓝色的惊叹号） console.error([data][, …]) 错误消息（红色的叉子） console.warn([data][, …]) 警告消息（黄色的惊叹号） console.dir(obj[, options]) 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示 console.time(label) 输出时间，表示计时开始 console.timeEnd(label) 结束时间，表示计时结束 console.trace(message[, …]) 当前执行的代码在堆栈中的调用路径 console.assert(value[, message][, …]) 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果 Node.js 常用工具 util.inherits实现对象间原型继承，仅仅继承在原型中定义的函数，构造函数内的不继承 util.inspect将任意对象转换为字符串 util.isArray(object) util.isRegExp(object) util.isDate(object) util.isError(object) Node.js 文件系统https://www.runoob.com/nodejs/nodejs-fs.html Node.js GET/POST请求https://www.runoob.com/nodejs/node-js-get-post.html Node.js Web 模块1234567891011121314151617181920212223242526272829303132333435//创建服务端server.jsvar http = require('http');var fs = require('fs');var url = require('url');// 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(\"Request for \" + pathname + \" received.\"); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;); &#125;).listen(8080); // 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8080/'); 123456789101112131415161718192021222324252627//创建客户端client.js//新打开一个终端，执行client.jsvar http = require('http'); // 用于请求的选项var options = &#123; host: 'localhost', port: '8080', path: '/index.html' &#125;; // 处理响应的回调函数var callback = function(response)&#123; // 不断更新数据 var body = ''; response.on('data', function(data) &#123; body += data; &#125;); response.on('end', function() &#123; // 数据接收完成 console.log(body); &#125;);&#125;// 向服务端发送请求var req = http.request(options, callback);req.end(); Node.js Express 框架https://www.runoob.com/nodejs/nodejs-express-framework.htmlExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站. Express 框架核心特性： 可以设置中间件来响应 HTTP 请求 定义了路由表用于执行不同的 HTTP 请求动作 可以通过向模板传递参数来动态渲染 HTML 页面 Node.js 多进程我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。 Node.js 连接 MySQLhttps://www.runoob.com/nodejs/nodejs-mysql.html Node.js 连接 MongoDBhttps://www.runoob.com/nodejs/nodejs-mongodb.html","comments":true,"tags":[{"name":"JS","slug":"JS","permalink":"https://miaoq.github.io/tags/JS/"}]},{"title":"BFC","date":"2018-06-08T07:06:57.000Z","path":"2018/06/08/CSS-2018-06-08-BFC/","text":".container{ border: 1px dashed gray; } .left{ float: left; } .right{ float: right; } .bfc{ overflow: hidden; } .line-b{ display: inline-block; } .abs{ position: absolute; } .box { color: #f55; background: #fcc; width: 150px; height: 150px; line-height: 150px; text-align:center; margin: 30px; } .first{ margin:20px; background:lightgreen; width:100px; height:100px; } .list{ margin:10px; background:lightblue; } .list > li{ margin:25px; } .aside { width: 100px; height: 150px; float: left; background: #f66; } .main { height: 200px; background: #fcc; } .left-box{ background:pink; width:150px; height: 150px; } .center-box{ background:lightyellow; height: 150px; } .right-box{ background: lightblue; width:150px; height: 150px; } 哪些元素会生成BFC（可以通过以下任意合适的方式触发box生成BFC）? 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed BFC的约束规则: 内部的Box会在垂直方向上一个接一个的放置 属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷） 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 1 2 3","comments":true,"tags":[{"name":"CSS","slug":"CSS","permalink":"https://miaoq.github.io/tags/CSS/"}]},{"title":"React入门（二）","date":"2018-05-25T01:28:28.000Z","path":"2018/05/25/JS-2018-05-25-React入门（二）/","text":"深入JSX指定 React 元素类型 从本质上讲，JSX 只是为 React.createElement(component, props, …children) 函数提供的语法糖 一个 JSX 标签的开始部分决定了 React 元素的类型 首字母大写的标签指示 JSX 标签是一个 React 组件 用户定义组件必须以大写字母开头 12345678910111213141516/*对 JSX 类型使用点语法在 JSX 中，你也可以使用点语法引用一个 React 组件。如果你有一个单一模块(module) ，但却 导出(exports) 多个 React 组件时，这将会很方便。*/import React from 'react';const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=\"blue\" /&gt;;&#125; JSX 中的 props(属性) JavaScript 表达式可以作为 props(属性) props(属性) 默认为 “true” 1234567891011121314151617/*如果你已经有一个 object 类型的 props，并且希望在 JSX 中传入，你可以使用扩展操作符 ... 传入整个 props 对象。*//*当你构建一个一般容器时，属性扩展非常有用。然而，这可能会使得你的代码非常混乱，因为这非常容易使一些不相关的 props(属性) 传递给组件，而组件并不需要这些 props(属性) 。因此我们建议谨慎使用该语法。*/function App1() &#123; return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; JSX 中的 Children JavaScript 表达式可以作为 Children(子元素)通过使用 {} 包裹，你可以将任何的 JavaScript 元素而作为 children(子元素) 传递 Functions(函数) 可以作为 Children(子元素)通常情况下，嵌入到 JSX 中的 JavaScript 表达式会被认为是一个字符串、React元素 或者是这些内容的一个列表。然而， props.children 类似于其他的 props(属性) ，可以被传入任何数据，而不是仅仅只是 React 可以渲染的数据。例如，如果有自定义组件，其 props.children 的值可以是回调函数 Booleans, Null, 和 Undefined 被忽略 使用 PropTypes 进行类型检查随着应用规模的提升，你可以通过类型检测捕获更多的bug。React 内置了类型检测的功能，要在组件中进行类型检测，你可以赋值 propTypes 属性。具体用法：http://www.css88.com/react/docs/typechecking-with-proptypes.html 像 Flow 和 TypeScript 这样的静态类型检查器可以在运行代码之前识别某些类型的问题。 他们还可以通过添加自动完成功能来改善开发人员的工作流程。 出于这个原因，对于更大的代码库我们建议使用 Flow 或者 TypeScript 来替代 PropTypes。 Flow、TypeScript用法：http://www.css88.com/react/docs/static-type-checking.html Refs 和 DOM使用 refs 的场景: 处理focus、文本选择或者媒体播放 触发强制动画 集成第三方DOM库 解决了一些从父组件访问子组件的DOM元素的方法（后续再仔细研究吧，云里雾里~~） 不受控组件在受控组件中，表单数据由 React 组件负责处理。在不受控组件中，其表单数据由 DOM 元素本身处理。 优化性能 在开发时使用开发版本（React包含很多在开发过程中很有帮助的警告，体积大），发布时使用生产版本插件的配置http://www.css88.com/react/docs/optimizing-performance.html 避免重新渲染 避免更新 不要突变(mutate) props 或 state 的值 使用 Immutable 数据结构 一致性比较添加key属性 片段React 中一个常见模式是为一个组件返回多个元素。 片段(fragments) 可以让你将子元素列表添加到一个分组中，并且不会在DOM中增加额外节点。 123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; );&#125; 动机 一个常见模式是为一个组件返回一个子元素列表 1234567891011class Table extends React.Component &#123; render() &#123; return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); &#125;&#125; 为了渲染有效的 HTML ， &lt;Columns /&gt; 需要返回多个 &lt;td&gt; 元素。如果 &lt;Columns /&gt; 的 render() 函数里面使用一个父级 div ，那么最终生成的 HTML 将是无效的。所以，这种情况就需要使用 Fragment: 12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); &#125;&#125; 简写语法可以像使用其他元素一样使用&lt;&gt;&lt;/&gt;，只是它不支持 键(keys) 或 属性(attributes)。但是目前很多工具都不支持。12345678910class Columns extends React.Component &#123; render() &#123; return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); &#125;&#125; 如果你需要一个带 key 的片段，你可以直接使用 &lt;React.Fragment /&gt; 。 一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：key 是唯一可以传递给 Fragment 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。12345678910111213function Glossary(props) &#123; return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // 没有`key`，将会触发一个key警告 &lt;React.Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/React.Fragment&gt; ))&#125; &lt;/dl&gt; );&#125; 插槽(Portals)通常来说，当你从组件的 render 方法返回一个元素时，它将被作为子元素被装载到最近父节点 DOM 中。然而，有时候需要将子元素插入到 DOM 节点的其他位置。Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。 错误边界(Error Boundaries)过去，组件内的 JavaScript 错误常常会破坏 React 内部状态,并导致它在下一次渲染时产生 神秘的 错误。这些错误总会在应用代码中较早的错误引发的，但 React 并没有提供一种方式能够在组件内部优雅地来处理，也不能从错误中恢复。 错误边界是 React 组件，它可以在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ** ，而不是使整个组件树崩溃。 错误边界(Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。 注意错误边界 无法 捕获如下错误: 事件处理 异步代码 （例如 setTimeout 或 requestAnimationFrame 回调函数） 服务端渲染 错误边界自身抛出来的错误 （而不是其子组件） 如果一个类组件定义了一个名为 componentDidCatch(error, info) (info 是一个含有 componentStack 属性的对象。这一属性包含了错误期间关于组件的堆栈信息。): 的新生命周期方法，它将成为一个错误边界： 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 而后你可以像一个普通的组件一样使用： 123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; componentDidCatch() 方法机制类似于 JavaScript catch {}，但是针对组件。仅有类组件可以成为错误边界。实际上，大多数时间你仅想要定义一个错误边界组件并在你的整个应用中使用。 注意错误边界(Error Boundaries) 仅可以捕获其子组件的错误。错误边界无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会向上冒泡至最接近的错误边界。这也类似于 JavaScript 中 catch {} 的工作机制。 为何不使用 try/catch?try / catch 非常棒，但其仅能在命令式代码（imperative code）下可用。然而，React 组件是声明式的并且具体指出 声明 什么需要被渲染。错误边界保留了 React 原生的声明性质，且其行为符合你的预期。例如，即使错误发生 componentDidUpdate 时期由某一个深层组件树中的 setState 调用引起，其仍然能够冒泡到最近的错误边界。 一个AI:命令式编程 vs 声明式编程 http://www.vaikan.com/imperative-vs-declarative/ 如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try / catch 语句：123456789101112131415161718192021class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null &#125;; &#125; handleClick = () =&gt; &#123; try &#123; // Do something that could throw &#125; catch (error) &#123; this.setState(&#123; error &#125;); &#125; &#125; render() &#123; if (this.state.error) &#123; return &lt;h1&gt;Caught an error.&lt;/h1&gt; &#125; return &lt;div onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/div&gt; &#125;&#125; Web 组件React 和 web组件 被用以解决不同问题。Web组件为可重用组件提供了强大的封装能力，而React则是提供了保持DOM和数据同步的声明式库。二者目标互补。作为开发者，你可以随意地在Web组件里使用React，或者在React里使用Web组件，或都有。 高阶组件组件是React中代码重用的最小单元高阶组件是一个函数，能够接受一个组件并返回一个新的组件组件是将props转化成UI，然而高阶组件将一个组价转化成另外一个组件 如何创建 http://www.css88.com/react/docs/higher-order-components.html 警告: 不要在render函数中使用高阶组件 静态方法必须复制 Refs不会被传递 与其他库整合对于 React 之外的 DOM 节点操作，React 是不会去处理的，因为 React 内部有自己的渲染逻辑。当相同的 DOM 节点被外部的代码改变时，React 就会很迷茫，并不知道发生了什么。 但这也不意味着 React 无法与其他操作 DOM 节点的库一起使用，你只要清楚他们分别在做什么就可以了。 最简单的方式就是阻止 React 更新外部在操作的节点，那么你可以通过生成一个 React 根本不会去更新的元素来实现，比如空的 &lt;div /&gt;。 代码拆分打包(Bundling) 是一个处理过程，跟踪导入的文件并将其合并到单个文件：“包” 。然后，这个包文件可以包含到网页上，这样可以一次性加载整个应用程序。","comments":true,"tags":[{"name":"JS","slug":"JS","permalink":"https://miaoq.github.io/tags/JS/"}]},{"title":"React入门（一）","date":"2018-05-17T07:30:58.000Z","path":"2018/05/17/JS-2018-05-17-React入门（一）/","text":"JSXJSX是 JavaScrip 的一种扩展语法，可以生成 React “元素”。 JSX中可以嵌入js表达式。 JSX是一个表达式，编译之后，就变成了常规的 JavaScript 对象（想想js对象可以干什么，就可以用JSX来干什么，比如：在 if 语句或者是 for 循环中使用 JSX，用它给变量赋值，当做参数接收，或者作为函数的返回值）。 比起HTML，JSX更接近于JavaScript，所以React DOM使用驼峰(camelCase)属性命名约定, 而不是HTML属性名称。例如，class 在JSX中变为className，tabindex 变为 tabIndex。 Babel 将JSX编译成 React.createElement() 调用React.createElement()会创建下面这样一个对象： 12345678// 注意: 这是简化的结构const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;; 了解了上述步骤，仔细这个对象，就应该意识到： 空标签应该闭合 子元素散开的，应该在外层加个父元素包裹起来 12//应该用\"/\"闭合const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; 12345//这是错的，没法创建一个完整的对象const element = ( &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt;); 12345678const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;);//添加一个div包裹//多行时，用圆括号包裹起来，可减少意外添加分号的错误 元素渲染不同于浏览器的 DOM 元素， React 元素是普通的对象，非常容易创建。React DOM 会负责更新 DOM ，以匹配React元素 React 元素是不可突变（immutable）的. 一旦你创建了一个元素, 就不能再修改其子元素或任何属性。一个元素就像电影里的一帧: 它表示在某一特定时间点的 UI 。更新 UI 的唯一方法是创建一个新的元素, 并将其传入 ReactDOM.render() 方法。实际上，大多数 React 应用只会调用 ReactDOM.render() 一次，好的解决方法是将代码封装到有状态的组件中。 React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。 组件(Components) 和 属性(Props)组件就像JavaScript的函数，可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容。 渲染一个组件 元素也可以代表用户定义的组件当 React 遇到一个代表用户定义组件的元素时，它将 JSX 属性以一个单独对象的形式传递给相应的组件。 我们将其称为 “props”对象。 12345678910function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"Sara\" /&gt;;ReactDOM.render( element, document.getElementById('root'));//在页面上渲染 “Hello, Sara” 重述一下上面这个例子: 我们调用了 ReactDOM.render() 方法并向其中传入了 &lt;Welcome name=&quot;Sara&quot; /&gt; 元素。 React 调用 Welcome 组件，并向其中传入了 {name: &#39;Sara&#39;} 作为 props 对象。 Welcome 组件返回 &lt;h1&gt;Hello, Sara&lt;/h1&gt;。 React DOM 迅速更新 DOM，使其显示为 &lt;h1&gt;Hello, Sara&lt;/h1&gt;。 注意：组件名称总是以大写字母开始 Props 是只读的 状态(State) 和 生命周期1234function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;//函数式组件 123456class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;//类组件 把函数式组件转换为类组件： 创建一个继承自 React.Component 类的 ES6 class 同名类。 添加一个名为 render() 的空方法。 把原函数中的所有内容移至 render() 中。 在 render() 方法中使用 this.props 替代 props。 删除保留的空函数声明。 state 和 props 类似，但是它是私有的，并且由组件本身完全控制。 用类定义的组件有一些额外的特性， 这个”类专有的特性”， 指的就是局部状态。 12345constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;;&#125;//类组件应始终使用 props 调用基础构造函数 在类中添加生命周期方法 先了解下React 生命周期的三种状态： 1. 初始化 2.更新 3.销毁（参照https://www.cnblogs.com/qiaojie/p/6135180.html） 初始化： getDefaultProps()，设置默认的props，也可以用dufaultProps设置组件的默认属性 初始化状态，在constructor中定义this.state，此时可以访问this.props componentWillMount()，组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state render()，React最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行，此时就不能更改state了 componentDidMount()，组件渲染之后调用，只调用一次 更新： componentWillReceiveProps(nextProps)，组件初始化时不调用，组件接受新的props时调用 shouldComponentUpdate(nextProps, nextState),react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 componentWillUpdata(nextProps, nextState)，组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state render()，组件渲染 componentDidUpdate()，组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点 卸载： componentWillUnmount()，组件将要卸载时调用，一些事件监听和定时器需要在此时清除 在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。 this.props 由 React 本身设定, 而 this.state 具有特殊的含义，但如果需要存储一些不用于视觉输出的内容，则可以手动向类中添加额外的字段。 如果在 render() 方法中没有被引用, 它不应该出现在 state 中。 复用和封装 最原始粗暴，通过调 ReactDOM.render() 方法来更新渲染的输出: 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 通过封装，变得更复用： 把函数式组件转化为类组件 在类组件中添加本地状态(state) 在类中添加生命周期方法 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 回顾一下该过程，以及调用方法的顺序： 当 &lt;Clock /&gt; 被传入 ReactDOM.render() 时, React 会调用 Clock 组件的构造函数。 因为 Clock 要显示的是当前时间，所以它将使用包含当前时间的对象来初始化 this.state 。我们稍后会更新此状态。 然后 React 调用了 Clock 组件的 render() 方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配 Clock 的渲染输出。 当 Clock 输出被插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。在该方法中，Clock 组件请求浏览器设置一个定时器来一次调用 tick()。 浏览器会每隔一秒调用一次 tick() 方法。在该方法中， Clock 组件通过 setState() 方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过 setState(), React 得知了组件 state(状态)的变化, 随即再次调用 render() 方法，获取了当前应该显示的内容。这次，render() 方法中的 this.state.date 的值已经发生了改变，从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。 如果通过其他操作将 Clock 组件从 DOM 中移除了, React 会调用 componentWillUnmount() 生命周期钩子, 所以计时器也会被停止。 正确地使用 State(状态)（这部分仔细看看文档上的例子说明http://www.css88.com/react/docs/state-and-lifecycle.html）: 不要直接修改 state(状态)，用 setState() 代替 state(状态) 更新可能是异步的，React 为了优化性能，有可能会将多个 setState() 调用合并为一次更新 state(状态) 更新会被合并，当你调用 setState()， React 将合并你提供的对象到当前的状态中 setState() 的另一种使用形式：它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数 数据向下流动 一个组件（无论作为父组件还是子组件）无法获取另一个组件的信息（是否有状态，是函数组件还是类组件）（因此， state 经常被称为 本地状态 或 封装状态），但可以选择将 state(状态) 向下传递，作为其子组件的 props(属性) 单向数据流， 任何 state(状态) 始终由某个特定组件所有，并且从该 state(状态) 导出的任何数据 或 UI 只能影响树中 “下方” 的组件 处理事件通过 React 元素处理事件跟在 DOM 元素上处理事件的区别: React 事件使用驼峰命名，而不是全部小写 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串 在 React 中你不能通过返回 false 来阻止默认行为，必须明确调用 preventDefault 方法 12345678910111213141516function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault();//明确调用 preventDefault 方法 console.log('The link was clicked.'); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125;/* 这里的 e 是一个合成的事件, React 根据 W3C 规范 定义了这个合成事件， 所以你不需要担心跨浏览器的兼容性问题。*/ 当使用 React 时，你一般不需要调用 addEventListener 在 DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了 123456789101112131415161718192021222324252627282930313233343536373839class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 这个绑定是必要的，使`this`在回调中起作用 this.handleClick = this.handleClick.bind(this); /* 在JSX回调中你必须注意 this 的指向。在 JavaScript 中，类方法默认没有绑定的。 如果你忘记绑定 this.handleClick 并将其传递给onClick， 那么在直接调用该函数时，this 会是 undefined 。 这不是 React 特有的行为；这是 JavaScript 中的函数如何工作的一部分。 一般情况下，如果你引用一个后面没跟 () 的方法，例如 onClick=&#123;this.handleClick&#125; ， 那你就应该 绑定(bind) 该方法。 */ &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); //setState() 的另一种使用形式：它接受一个函数而不是一个对象 //此处省略了第二个参数 &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 123&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;&lt;!--将参数传递给事件处理程序，两种方式，参数 e 作为 React 事件对象将会被作为第二个参数进行传递--&gt; 条件渲染1234567//元素变量，可以用变量来存储元素let button = null;if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;&#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;&#125; 123456//使用逻辑 &amp;&amp; 操作符的内联 if 用法&#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt;&#125; 123456//使用条件操作符的内联 If-Elsereturn ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt;); 123456789101112//防止组件渲染，返回 null 而不是其渲染输出function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );&#125; 列表(Lists) 和 键(Keys)12345678910//多组件渲染const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;);ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root')); 12345678910111213141516171819202122//基本列表组件function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; /* 键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了 数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识 */ ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 在元素中调用 map() 的地方制定 keys keys 在同辈元素中必须是唯一的 1234567891011121314//在 JSX 中嵌入 map()function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125;//JSX允许在大括号中嵌入任何表达式，因此可以 内联 map() 结果 表单(Forms)在 HTML 中，表单元素如 &lt;input&gt;，&lt;textarea&gt; 和 &lt;select&gt; 表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过 setState() 更新。 我们可以通过“使 React 的 state 成为 单一数据源 ”原则 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。 12345678910111213141516171819202122232425262728293031class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; //html自身的event.target.value与React的state结合 handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 对于受控组件来说，每一次 state(状态) 变化都会伴有相关联的处理函数。这使得可以直接修改或验证用户的输入。比如，如果我们希望强制 name 的输入都是大写字母，可以这样来写 handleChange 方法： 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;);&#125; 1234567891011121314/* textare 标签 用 value 属性替代&lt;textarea&gt;的赋值，表单中&lt;textarea&gt;的书写方式接近于单行文本输入框 下面仅展示了部分代码*/this.state = &#123; value: 'Please write an essay about your favorite DOM element.'&#125;;handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;);&#125;return &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; 12345678910111213141516171819/* select 标签 在根 select 标签中使用了一个 value 属性，来选中选项 下面仅展示了部分代码*/this.state = &#123;value: 'coconut'&#125;;handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;);&#125;return ( ... &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; ...)//可以将一个数组传递给 value 属性，允许你在 select 标签中选择多个选项：&lt;select multiple=&#123;true&#125; value=&#123;['B', 'C']&#125;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*file input 标签在 React 中，一个 &lt;input type =“file”/&gt; 和一个普通的 &lt;input /&gt; 类似，但有一个重要的区别：它是只读的(read-only)。（您不能以编程方式设置值。）相反，你应该使用 File API 与文件进行交互。以下示例显示了如何使用一个 ref 来访问提交处理程序中的文件：*/class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind( this ); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123; this.fileInput.files[0].name &#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;input =&gt; &#123; this.fileInput = input; &#125;&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt; Submit &lt;/button&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( &lt;FileInput /&gt;, document.getElementById('root')); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*处理多个输入元素当您需要处理多个受控的 input 元素时，您可以为每个元素添加一个 name 属性，并且让处理函数根据 event.target.name 的值来选择要做什么。*/class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=\"isGoing\" type=\"checkbox\" checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=\"numberOfGuests\" type=\"number\" value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; 状态提升(Lifting State Up)通常情况下，同一个数据的变化需要几个不同的组件来反映。我们建议提升共享的状态到它们最近的祖先组件中。 在 React 中，共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。共享状态的原理：props(属性) 是只读的，而state可以通过调用this.setState()改变，因此，用props代替state，该props的值由父组件提供。 1234567891011121314151617181920212223242526272829303132333435363738394041class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: '', scale: 'c'&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: 'c', temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: 'f', temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=\"c\" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=\"f\" temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 现在，无论你编辑哪个输入框，Calculator 中的 this.state.temperature 和 this.state.scale 都会更新。其中一个输入框获取值，所以任何用户输入都被保留，并且另一个输入总是基于它重新计算值。 让我们回顾一下编辑输入时会发生什么： React 调用在 DOM &lt;input&gt; 上的 onChange 指定的函数。在我们的例子中，这是 TemperatureInput 组件中的 handleChange 方法。 TemperatureInput 组件中的 handleChange 方法使用 新的期望值 调用 this.props.onTemperatureChange()。TemperatureInput 组件中的 props(属性) ，包括 onTemperatureChange，由其父组件 Calculator 提供。 当它预先呈现时， Calculator 指定了摄氏 TemperatureInput 的 onTemperatureChange 是 Calculator 的 handleCelsiusChange 方法，并且华氏 TemperatureInput 的 onTemperatureChange 是 Calculator 的 handleFahrenheitChange 方法。因此，会根据我们编辑的输入框，分别调用这两个 Calculator 方法。 在这些方法中， Calculator 组件要求 React 通过使用 新的输入值 和 刚刚编辑的输入框的当前度量衡 来调用 this.setState() 来重新渲染自身。 React 调用 Calculator 组件的 render 方法来了解 UI 外观应该是什么样子。基于当前温度和激活的度量衡来重新计算两个输入框的值。这里进行温度转换。 React 使用 Calculator 指定的新 props(属性) 调用各个 TemperatureInput 组件的 render 方法。 它了解 UI 外观应该是什么样子。 React DOM 更新 DOM 以匹配期望的输入值。我们刚刚编辑的输入框接收当前值，另一个输入框更新为转换后的温度。 经验总结 在一个 React 应用中，对于任何可变的数据都应该循序“单一数据源”原则。通常情况下，state 首先被添加到需要它进行渲染的组件。然后，如果其它的组件也需要它，你可以提升状态到它们最近的祖先组件。你应该依赖 从上到下的数据流向 ，而不是试图在不同的组件中同步状态。 提升状态相对于双向绑定方法需要写更多的“模板”代码，但是有一个好处，它可以更方便的找到和隔离 bugs。由于任何 state(状态) 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少。另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。 如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它可能不应该在 state(状态) 中。例如，我们只保存最后编辑的 temperature 和它的 scale，而不是保存 celsiusValue 和 fahrenheitValue 。另一个输入框的值总是在 render() 方法中计算得来的。这使我们对其进行清除和四舍五入到其他字段同时不会丢失用户输入的精度。 React 开发者工具: https://github.com/facebook/react-devtools 组合 VS 继承（Composition vs Inheritance）一些组件在设计前无法获知自己要使用什么子组件 1234567891011121314151617181920212223242526function SplitPane(props) &#123; return ( &lt;div className=\"SplitPane\"&gt; &lt;div className=\"SplitPane-left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"SplitPane-right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125;//如 &lt;Contacts /&gt; 和 &lt;Chat /&gt; 等 React 元素本质上也是对象，//所以可以将其像其他数据一样作为 props(属性) 传递使用。 12345678910111213141516171819202122function Dialog(props) &#123; return ( &lt;FancyBorder color=\"blue\"&gt; &lt;h1 className=\"Dialog-title\"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;Dialog title=\"Welcome\" message=\"Thank you for visiting our spacecraft!\" /&gt; );&#125;//一个偏“特殊”的组件渲染出一个偏“通用”的组件 总结：使用 props(属性) 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数。如果要在组件之间重用非 U I功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。","comments":true,"tags":[{"name":"JS","slug":"JS","permalink":"https://miaoq.github.io/tags/JS/"}]},{"title":"SQL必知必会主要内容","date":"2018-05-13T02:05:58.000Z","path":"2018/05/13/DB-2018-05-13-SQL/","text":"简单入门123SELECT prod_id FROM Products;--输出prod_id列 12SELECT prod_id, prod_name FROM Products; 12SELECT * FROM Products ;--输出所有列 123SELECT DISTINCT prod_id FROM Products;--输出prod_id不同的列 检索前5行，各数据库有差异: 12SELECT TOP 5 prod_id FROM Products; 1234SELECT prod_id FROM Products WHERE ROWNUM &lt;= 5;--oraCal 123SELECT prod_id FORM Products LIMIT 5;--输出5行 1234SELECT prod_id FROM Products LIMIT 5 OFFSET 10;--从第10行开始，输出5行 12345--行内注释的一种方式#行内注释的另一种方式/* */块级注释 1234SELECT prod_name FROM Products ORDER BY prod_name;--按字母顺序排序 1234SELECT prod_id, prod_name, prod_price FROM Products ORDER BY prod_price, prod_name;--按多列排序 1234SELECT prod_id, prod_name, prod_price FROM Products ORDER BY 2, 3;--按相对列排序（此处下标从1开始） 1234SELECT prod_id, prod_name, prod_price FROM Products ORDER BY prod_price DESC;--按降序排列，价格从高到低 1234SELECT prod_id, prod_name, prod_price FROM Products ORDER BY prod_price DESC, prod_name;--按降序排列，价格从高到低，name还是按字母升序排列 123SELECT prod_name, prod_price FROM Producs WHERE prod_price = 3.49; 同时使用WHERE和ORDER BY时，ORDER BY应放在WHERE之后 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 !&lt;= 不等于 &lt; 小于 &lt;= 小于等于 ! 不小于 &gt; 大于 &gt;= 大于等于 !&gt; 不大于 BETWEEN 在指定的两个值之间 IS NULL 为NULL值 123SELECT prod_name, prod_price FROM Products WHERE prod_price &lt; 10; 123SELECT vent_id, prod_name FROM Products WHERE vent_id &lt;&gt; 'DLL01'; 单引号用来限定字符串，如果将值与字符串比较就需要用单引号包起来，如果与数值比较就不需要。我觉得最好就都包呗~ 有&lt;&gt;和!=是因为DBMS支持上的差异 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10; 1234SELECT prod_nameFROM ProductsWHERE prod_price IS NULL;--空值 组合WHERE子句1234SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = 'DLL01' AND prod_price &lt;= 4;--可以加好多个AND 1234SELECT prod_name, prod_priceFROM ProductsWHERE vend_id = 'DLL01' OR vend_id = ‘BRS01’;--如果OR前面的为true，则一定会打印 1234SELECT prod_name, prod_priceFROM ProductsWHERE (vend_id = 'DLL01' OR vend_id = ‘BRS01’) AND prod_price &gt;= 10;--AND优先级高于OR 12345SELECT prod_name, prod_price FROM ProductsWHERE vend_id IN ( 'DLL01', 'BRS01' ) ORDER BY prod_name;--IN操作符完成了与OR一样的功能，但是更简洁，直观 12345SELECT prod_nameFROM ProductsWHERE NOT vend_id = 'DLL01' ORDER BY prod_name;--NOT操作符否定其后跟的任何条件 使用通配符过滤123456SELECT prod_id, prod_name FROM ProductsWHERE prod_name LIKE 'Fish%';--LIKE操作符--%通配符代表搜索模式中给定位置的0个、1个或多个字符（除NULL外）（Access使用*）--找出所有以词Fish起头的产品 1234SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '%bean bag%';--可以使用任意个% 1234SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '_ inch teddy bear';--_通配符只匹配单个字符，可以使用多个_（Access使用?） 12345SELECT cust_contactFROM CustomersWHERE cust_contact LIKE '[JM]%' ORDER BY cust_contact;--[JM]匹配任何以方括号中字母(J或者M)开头的联系人名,它也只能匹配单个字符 12345SELECT cust_contactFROM CustomersWHERE cust_contact LIKE '[^JM]%' ORDER BY cust_contact;--^脱字号匹配不以J或M起头的任意联系人名 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间： 不要过度使用通配符，如果其它操作符能达到目的，就使用其它操作符 尽量不要用在搜索模式的开始处，用在开始处是最慢的 创建计算字段1234SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' FROM VendorsORDER BY vend_name;--拼接两列，+或者||（各数据库有差别）--RTRIM去掉右边空格 1234SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' AS vend_titleFROM VendorsORDER BY vend_name;--AS后面是合并后的新列的名称（别名Alias） 12345SELECT prod_id, quantity, item_price,quantity*item_price AS expanded_price FROM OrderItemsWHERE order_num = 20008;--输出中显示的expanded_price列是一个计算字段,此计算为quantity*item_price SELECT语句为测试、检验函数和计算提供了很好的方法。虽然SELECT通常用于从表中检索数据,但是省略了FROM子句后就是简单地访问 和处理表达式,例如SELECT 3 * 2;将返回6,SELECT Trim(‘ abc ‘);将返回abc,SELECT Now();使用Now()函数返回当前日期和时间。现在 你明白了,可以根据需要使用SELECT语句进行检验。 使用数据处理函数1234SELECT vend_name, UPPER(vend_name) AS vend_name_upcase FROM VendorsORDER BY vend_name;--UPPER()函数将文本转换为大写（这里列出了两列，原来的和转换后的） 常用的文本处理函数： 函数 说明 LEFT()(或使用子字符串函数) 返回字符串左边的字符 LENGTH()(也使用DATALENGTH()或LEN()) 返回字符串的长度 LOWER()(Access使用LCASE()) 将字符串转换为小写 LTRIM() 去掉字符串左边的空格 RIGHT()(或使用子字符串函数) 去掉字符串右边的空格 RTRIM() 去掉字符串右边的空格 SOUNDEX() 返回字符串的SOUNDEX值 UPPER()(Access使用UCASE()) 将字符串转换为大写 1234SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green');--SOUNDEX发音类似函数（神奇！） 1234SELECT order_numFROM OrdersWHERE DATEPART(yy, order_date) = 2012;--DATEPART检索日期的函数（还有其它版本） 数值处理函数： 函数 说明 ABS() 返回一个数的绝对值 COS() 返回一个角度的余弦 EXP() 返回一个数的指数值 PI() 返回圆周率 SIN() 返回一个角度的正弦 SQRT() 返回一个数的平方根 TAN() 返回一个角度的正切 聚集函数对某些行运行的函数,计算并返回一个值 我们经常需要汇总数据而不用把它们实际检索出来 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列之和 1234567SELECT AVG(prod_price) AS avg_price FROM ProductsWHERE vend_id = 'DLL01';/* AVG()可用来返回所有列的平均值,也可以用来返回特定列或行的平均值.要获得多个列的平均值,必须使用多个AVG()函数*/ 123456SELECT COUNT(cust_email) AS num_cust FROM Customers;/*如果指定列名,则COUNT()函数会忽略指定列的值为空的行,但如果COUNT()函数中用的是星号(*),则不忽略*/ 123456789SELECT MAX(prod_price) AS max_price FROM Products;/*虽然MAX()一般用来找出最大的数值或日期值,但许多(并非所有)DBMS允许将它用来返回任意列中的最大值,包括返回文本列中的最大 值。在用于文本数据时,MAX()返回按该列排序后的最后一行(MIN()与其相反)。MAX()/MIN()函数忽略列值为NULL的行。*/ 12345SELECT SUM(item_price*quantity) AS total_price FROM OrderItemsWHERE order_num = 20005;--SUM()函数忽略列值为NULL的行--如本例所示，所有聚集函数都可以用来执行多个列以上的运算 以上5个聚集函数都可以如下使用: 对所有行执行计算,指定A LL参数或不指定参数(因为A LL是默认行为)。 只包含不同的值,指定DISTINCT参数 提示:ALL为默认，无需指定 1234SELECT AVG(DISTINCT prod_price) AS avg_price FROM ProductsWHERE vend_id = 'DLL01';--警告:DISTINCT不能用于COUNT(*) 1234567SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM Products;--组合使用聚集函数 分组数据两个新SELECT语句子句：创建分组GROUP BY子句和过滤分组HAVING子句 1234SELECT vend_id, COUNT(*) AS num_prods FROM ProductsGROUP BY vend_id;--GROUP BY会对每个vend_id而不是整个表计算num_prods一次 GROUP BY的一些规定： GROUP BY子句可以包含任意数目的列,因而可以对分组进行嵌套,更细致地进行数据分组 如果在GROUP BY子句中嵌套了分组,数据将在最后指定的分组上进行汇总。换句话说,在建立分组时,指定的所有列都一起计算(所以 不能从个别的列取回数据) 如果在GROUP BY子句中嵌套了分组,数据将在最后指定的分组上进行汇总。换句话说,在建立分组时,指定的所有列都一起计算(所以 不能从个别的列取回数据) 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型(如文本或备注型字段) 除聚集计算语句外,SELECT语句中的每一列都必须在GROUP BY子句中给出 如果分组列中包含具有NULL值的行,则NULL将作为一个分组返回。如果列中有多行NULL值,它们将分为一组 GROUP BY子句必须出现在WHERE子句之后,ORDER BY子句之前 12345SELECT cust_id, COUNT(*) AS orders FROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2;--HAVING过滤COUNT(*) &gt;= 2(两个以上订单)的那些分组 HAVING和WHERE的差别：WHERE在数据分组前进行过滤,HA VING在数据分组后进行过滤。这是一个重要的区别,WHERE排除的行不包括在分组中。这可能会改变计算值,从而影响HA VING子句中基于这些值过滤掉的分组.使用HAVING时应 该结合GROUP BY子句,而WHERE子句用于标准的行级过滤。 1234SELECT vend_id, COUNT(*) AS num_prods FROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2; 分组和排序：ORDER BY与GROUP BY ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的排序 任意列（甚至非选择的列）都可以使用 只可能使用选择列或表达式列,而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 1234567891011SELECT order_num, COUNT(*) AS items FROM OrderItemsGROUP BY order_numHAVING COUNT(*) &gt;= 3ORDER BY items, order_num;/*在这个例子中,使用GROUP BY子句按订单号(order_num列)分组数据,以便COUNT(*)函数能够返回每个订单中的物品数目。HAVING子句过滤数据,使得只返回包含三个或更多物品的订单。最后,用ORDER BY子句排序输出。*/ SELECT子句顺序 字句 说明 是否必须使用 SELECT 要返回的列表或表达式 是 FROM 从中检索数据的表 仅在从表中检索数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 子查询1234567891011SELECT cust_idFROM OrdersWHERE order_num IN (SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_numFROM OrderItemsWHERE prod_id = 'RGAN01'); FROM OrderItems WHERE prod_id = 'RGAN01');--从内向外处理，先SELECT order_num... 联结表创建联结: 1234SELECT vend_name, prod_name, prod_price FROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id;--WHERE子句指示DBMS将Vendors表中的vend_id与Products表中的vend_id匹配起来 1234SELECT vend_name, prod_name, prod_price FROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id;--联结条件用特定的ON子句给出 联结多个表： 123456SELECT prod_name, vend_name, prod_price, quantity FROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_id AND order_num = 20007;--不要联结不必要的表，非常耗资源 高级联结使用表别名： 123456SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_idAND OI.order_num = O.order_num AND prod_id = 'RGAN01';--缩短SQL语句--允许在一条SELECT语句中多次使用相同的表 123456SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01';--自然联结 12345SELECT Customers.cust_id, Orders.order_num FROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_id;--内联结 12345SELECT Customers.cust_id, Orders.order_num FROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id;--外联结 12345SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN Orders ON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id;--带聚集函数的联结 创建组合查询12345678SELECT cust_name, cust_contact, cust_email FROM CustomersWHERE cust_state IN ('IL','IN','MI')UNIONSELECT cust_name, cust_contact, cust_email FROM CustomersWHERE cust_name = 'Fun4All';--UNION与使用多条WHERE子句相同，如下个例子 1234SELECT cust_name, cust_contact, cust_email FROM CustomersWHERE cust_state IN ('IL','IN','MI') OR cust_name = 'Fun4All';--参照例子，多个WHERE子句 UNION规则 UNION必须由两条或两条以上的SELECT语句组成,语句之间用关键字UNION分隔(因此,如果组合四条SELECT语句,将要使用三 个UNION关键字) UNION中的每个查询必须包含相同的列、表达式或聚集函数(不过,各个列不需要以相同的次序列出) 列数据类型必须兼容:类型不必完全相同,但必须是DBMS可以隐含转换的类型(例如,不同的数值类型或不同的日期类型) 使用UNION时,重复的行会被自动取消,如果想返回所有的匹配行,可使用UNION ALL;在用UNION组合查询时,只能使用一条ORDER BY子句,它必须位于最后一条SELECT语句之后 插入数据INSERT用来将行插入(或添加)到数据库表 123456789INSERT INTO Customers VALUES('1000000006','Toy Land','123 Any Street', 'New York','NY','11111','USA',NULL,NULL);--插入完整的行 12345678INSERT INTO Customers(cust_id, cust_name,cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES('1000000006', 'Toy Land','123 Any Street', 'New York','NY','11111','USA', NULL, NULL);--给出了列名虽然繁琐，但是更安全，可以打乱顺序，还可以只插入部分行 123456INSERT INTO Customers(cust_id, cust_contact,cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id,cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM CustNew;--插入检索出的数据（将SELECT语句的结果插入表中） INSERT通常只插入一行。要插入多行,必须执行多个INSERT语句。INSERT SELECT是个例外,它可以用一条INSERT插入多行,不 管SELECT语句返回多少行,都将被INSERT插入。 从一个表复制到另一个表 12345678910SELECT *INTO CustCopy FROM Customers;/*这条SELECT语句创建一个名为CustCopy的新表,并把Customers表的整个内容复制到新表中。因为这里使用的是SELECT *,所以将在CustCopy表中创建(并填充)与Customers表的每一列相同的列。要想只复制部分的列,可以明确给出列名,而不是使用*通配符。*/ 使用SELECT INTO时: 任何SELECT选项和子句都可以使用,包括WHERE和GROUP BY 可利用联结从多个表插入数据 不管从多少个表中检索数据,数据都只能插入到一个表中 更新和删除数据UPDATE和DELETE 注意安全 1234UPDATE CustomersSET cust_contact = 'Sam Roberts',cust_email = 'sam@toyland.com' WHERE cust_id = '1000000006'; 1234UPDATE CustomersSET cust_email = NULLWHERE cust_id = '1000000005';--要删除某个列的值,可设置它为NULL 1234DELETE FROM Customers WHERE cust_id = '1000000006';--删除一行，即使删除了所有行，也不删除表--删除所有行,可使用TRUNCATE TABLE语句,速度更快 更新和删除的指导原则: 除非确实打算更新和删除每一行,否则绝对不要使用不带WHERE子句的UPDA TE或DELETE语句 保证每个表都有主键，尽可能像WHERE子句那样使用它 在UPDA TE或DELETE语句使用WHERE子句前,应该先用SELECT进行测试,保证它过滤的是正确的记录,以防编写的WHERE子句不正确 使用强制实施引用完整性的数据库 有的DBMS允许数据库管理员施加约束,防止执行不带WHERE子句的UPDA TE或DELETE语句。如果所采用的DBMS支持这个特性,应该使用它 创建表12345678CREATE TABLE Products (prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL DEFAULT 1,,prod_desc VARCHAR(1000) NULL--缺省时，使用默认值); 允许NULL值的列也允许在插入行时不给出该列的值不允许NULL值的列不接受没有列值的行 更新表 12ALTER TABLE VendorsADD vend_phone CHAR(20); 12ALTER TABLE Vendors DROP COLUMN vend_phone; 使用ALTER TABLE要极为小心,应该在进行改动前做完整的备份(模式和数据的备份)。数据库表的更改不能撤销,如果增加了不需要的 列,也许无法删除它们。类似地,如果删除了不应该删除的列,可能会丢失该列中的所有数据。 删除表 1DROP TABLE CustCopy; 视图123456CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num;--创建视图 1234SELECT cust_name, cust_contact FROM ProductCustomersWHERE prod_id = 'RGAN01';--使用视图 12345CREATE VIEW VendorLocations ASSELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'AS vend_title FROM Vendors;--用视图重新格式化检索出的数据 12345CREATE VIEW CustomerEMailList AS SELECT cust_id, cust_name, cust_email FROM CustomersWHERE cust_email IS NOT NULL;--用视图过滤不想要的数据 12345678CREATE VIEW OrderItemsExpanded AS SELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItems;--使用视图与计算字段 视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次,可用来简化数据处理,重新格 式化或保护基础数据。 使用存储过程1234EXECUTE AddNewProduct( 'JTS01', 'Stuffed Eiffel Tower',6.49,'Plush stuffed toy with the text La ➥Tour Eiffel in red white and blue' );--执行存储过程 123456789CREATE PROCEDURE MailingListCount ( ListCount OUT INTEGER)IS v_rows INTEGER; BEGINSELECT COUNT(*) INTO v_rows FROM CustomersWHERE NOT cust_email IS NULL; ListCount := v_rows;END;--创建存储过程（oracle） 事务处理123456789101112131415161718192021BEGIN TRANSACTIONINSERT INTO Customers(cust_id, cust_name)VALUES('1000000010', 'Toys Emporium');SAVE TRANSACTION StartOrder;INSERT INTO Orders(order_num, order_date, cust_id) VALUES(20100,'2001/12/1','1000000010');IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price) VALUES(20100, 1, 'BR01', 100, 5.49);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price) VALUES(20100, 2, 'BR03', 100, 10.99);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;COMMIT TRANSACTION/*这里的事务处理块中包含了4条INSERT语句。在第一条INSERT语句之后定义了一个保留点,因此,如果后面的任何一个INSERT操作失败,事 务处理最近回退到这里。在SQL Server中,可检查一个名为@@ERROR的变量,看操作是否成功。(其他DBMS使用不同的函数或变量返回此 信息。)如果@@ERROR返回一个非0的值,表示有错误发生,事务处理回退到保留点。如果整个事务处理成功,发布COMMIT以保留数据。*/ 游标有时,需要在检索出来的行中前进或后退一行或多行,这就是游标的用途所在。游标(cursor)是一个存储在DBMS服务器上的数据库查询,它不是一条SELECT语句,而是被该语句检索出来的结果集。在存储了游标之后,应用程序可以根据需要滚动或浏览其中的数据。 1234DECLARE CURSOR CustCursor ISSELECT * FROM Customers WHERE cust_email IS NULL--创建游标 1234567891011DECLARE TYPE CustCursor IS REF CURSOR RETURN Customers%ROWTYPE;DECLARE CustRecord Customers%ROWTYPE BEGINOPEN CustCursor;FETCH CustCursor INTO CustRecord; CLOSE CustCursor;END;--使用游标OPEN CURSOR CustCursor--关闭游标CLOSE CustCursor 高级数据处理特性：约束、索引和触发器123CREATE INDEX prod_name_ind ON PRODUCTS (prod_name);--创建索引 12345678CREATE TRIGGER customer_state AFTER INSERT OR UPDATE FOR EACH ROWBEGINUPDATE CustomersSET cust_state = Upper(cust_state) WHERE Customers.cust_id = :OLD.cust_id END;--触发器 建议使用：Oracle SQL Developer SQL语句语法ALTER TABLE：用来更新已存在表的结构COMMIT：用来将事务写入数据库CREATE INDEX：用于在一个或多个列上创建索引CREATE PROCEDURE：用于创建存储过程CREATE TABLE：用于创建新数据库表CREATE VIEW：用来创建一个或多个表上的新视图DELETE从：表中删除一行或多行DROP：永久地删除数据库对象(表、视图、索引等)INSERT：为表添加一行INSERT SELECT：将SELECT的结果插入到一个表ROLLBACK：用于撤销一个事务块SELECT：用于从一个或多个表(视图)中检索数据UPDATE：更新表中的一行或多行 数据类型字符串数据类型 数据类型 说明 CHAR 1~255个字符的定长字符串。它的长度必须在创建时规定 NCHAR CHAR的特殊形式,用来支持多字节或Unicode字符(此类型的不同实现变化很大) NVARCHAR TEXT的特殊形式,用来支持多字节或Unicode字符(此类型的不同实现变化很大) TEXT(也称为LONG、MEMO或VARCHAR) 变长文本 不管使用何种形式的字符串数据类型，字符串值都必须括在单引号内 如果数值是计算(求和、平均等)中使用的数值,则应该存储在数值数据类型列中;如果作为字符串(可能只包含 数字)使用,则应该保存在字符串数据类型列中。 数值数据类型 数据类型 说明 BIT 单个二进制位值,或者为0或者为1,主要用于开/关标志 DECIMAL(或NUMERIC) 定点或精度可变的浮点值 FLOAT(或NUMBER) 浮点值 INT(或INTEGER) 4字节整数值,支持-2147483648~2147483647的数 REAL 4字节浮点值 SMALLINT 2字节整数值,支持-32768~32767的数 TINYINT 1字节整数值,支持0~255的数 日期和时间数据类型 数据类型 说明 DATE 日期值 DATETIME(或TIMESTAMP) 日期时间值 SMALLDATETIME 日期时间值，精确到分（无秒或毫秒） TIME 时间值 二进制数据类型 数据类型 说明 BINARY 定长二进制数据(最大长度从255字节到8000字节,有赖于具体的实现) LONG RAW 变长二进制数据,最长2 GB RAW(某些实现为BINARY) 定长二进制数据,最多255字节 VARBINARY 变长二进制数据(最大长度一般在255字节到8000字节间变化,依赖于具体的实现)","comments":true,"tags":[{"name":"DB","slug":"DB","permalink":"https://miaoq.github.io/tags/DB/"}]}]